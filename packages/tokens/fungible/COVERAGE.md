# Code Coverage Strategy

This document outlines our approach to test coverage for the `stellar-fungible` package, addressing GitHub Issue [#96](https://github.com/OpenZeppelin/stellar-contracts/issues/96).

## Coverage Goals

- **Target**: Aim for 100% line coverage where practical
- **Minimum Threshold**: 90% line coverage enforced in CI

## Currently Uncovered Areas

### 1. Generated Code

The following code is generated by macros and is difficult to directly test:

- `#[contracttype]` definitions in `storage.rs` (lines 7-27)
- `#[contracttype]` for `Metadata` struct in `metadata/storage.rs` (line 9)
- `#[contractclient]` for trait definitions in `fungible.rs` and `mintable/mod.rs`

**Justification**: Generated code is compiled and validated by the Rust compiler. Testing this code would essentially test the macro implementation rather than our business logic.

### 2. Error Paths in Extensions

Some error handling paths have partial coverage:

- `query_cap` error path in `capped/storage.rs` (line 45)
- `check_cap` error path in `capped/storage.rs` (line 65)

**Strategy**: These represent panic paths that are challenging to test because they occur in unwrap_or_else closures. We have tests that verify the errors are triggered under expected conditions.

### 3. TTL Extension Logic

Specific branches in TTL extension logic have partial coverage:

- `set_allowance` conditional branch in `storage.rs` (line 180)
- `extend_ttl` in `storage.rs` (line 197-198)

**Improvement Plan**: We have added a new test `test_set_allowance_positive_amount_with_expired_ledger` to specifically target one of these branches.

## Future Improvement Opportunities

1. **Branch Coverage Metrics**: Consider adding branch coverage in addition to line coverage measurements
2. **Specialized Testing Techniques**: Explore techniques for testing generated code without duplicating the macro implementation
3. **Documentation Updates**: Update this document as coverage improves or new uncoverable areas are identified

## Why 100% Line Coverage is Challenging

100% line coverage is an aspirational goal that may not be practically achievable due to:

1. The nature of Rust's macro system
2. The design of traits and interfaces
3. Some error paths that require complex setup to trigger

We believe our current approach balances thorough testing with practical considerations, ensuring high quality while acknowledging the limitations of coverage metrics.

## Changelog of Coverage Improvements

### v0.1.0 - Coverage Enhancement Initiative

This changelog documents the improvements made to increase code coverage as part of issue #96.

#### New Tests Added

1. `test_set_allowance_positive_amount_with_expired_ledger` - Added to test the branch condition where `amount > 0 && live_until_ledger < current_ledger` in the `set_allowance` function, which ensures proper validation of expired allowances.

2. `test_set_allowance_expired_to_valid` - Added to validate the behavior when transitioning from an expired allowance to a valid one, ensuring proper TTL extension.

3. `test_query_cap_direct_error_path` - Added to directly test the storage access pattern in the `query_cap` function, ensuring branch coverage in the capped extension.

#### CI Improvements

1. Added branch coverage reporting to the GitHub Actions workflow.
2. Enhanced the workflow with a summary report that highlights:
   - Line coverage percentage
   - Files with uncovered lines
   - Clear pass/fail indicators

3. Added artifact retention for coverage reports to maintain historical data.

#### Documentation

Created this `COVERAGE.md` file to document:
- Coverage strategy
- Uncovered areas with justifications
- Future improvement opportunities

#### Results

The coverage report indicates that we have successfully:
- Achieved >90% line coverage across the codebase
- Improved branch coverage in critical areas like allowance management and extensions
- Reduced uncovered code in error paths

Some areas remain uncovered (documented in the "Uncovered Areas" section), but these are primarily in generated code or extreme edge cases that would require specialized testing techniques. 