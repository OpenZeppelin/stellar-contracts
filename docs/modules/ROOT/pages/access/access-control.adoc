:source-highlighter: highlight.js
:highlightjs-languages: rust
:github-icon: pass:[<svg class="icon"><use href="#github-icon"/></svg>]
= Access Control

https://github.com/OpenZeppelin/stellar-contracts/tree/main/packages/access/access-control[Source Code]

== Overview

The Access Control module provides a comprehensive role-based access control system for Soroban contracts. It enables developers to manage permissions through a hierarchical role system, with a single overarching admin and customizable role assignments.

== Key Concepts

=== Admin Management

The system features a single top-level admin with privileges to call any function in the `AccessControl` trait. This admin must be set during contract initialization for the module to function properly.

Admin transfers are implemented as a two-step process to prevent accidental or malicious takeovers:

1. The current admin *initiates* the transfer by specifying the new admin and an expiration time (`live_until_ledger`).
2. The designated new admin must *explicitly accept* the transfer to complete it.

Until the transfer is accepted, the original admin retains full control and can override or cancel the transfer by initiating a new one or using a `live_until_ledger` of `0`.

=== Role Hierarchy

The module supports a hierarchical role system where each role can have an "admin role" assigned to it. For example:

* Create roles `minter` and `minter_admin`
* Assign `minter_admin` as the admin role for the `minter` role
* Accounts with the `minter_admin` role can grant/revoke the `minter` role to other accounts

This allows for creating complex organizational structures with chains of command and delegated authority.

=== Role Enumeration

The system tracks account-role pairs in storage with additional enumeration logic:

* When a role is granted to an account, the pair is stored and added to enumeration storage
* When a role is revoked, the pair is removed from storage and enumeration
* If all accounts are removed from a role, the helper storage items become empty or 0

Roles exist only through their relationships with accounts, so a role with zero accounts is indistinguishable from a role that never existed.

== Implementation

=== Core Functions

* `set_admin(e: &Env, admin: &Address)`: Sets the contract admin
* `get_admin(e: &Env) -> Address`: Returns the current admin
* `transfer_admin_role(e: &Env, new_admin: &Address, live_until_ledger: u32)`: Initiates admin transfer
* `accept_admin_transfer(e: &Env)`: Accepts an admin transfer
* `grant_role(e: &Env, account: &Address, role: &Symbol)`: Grants a role to an account
* `revoke_role(e: &Env, account: &Address, role: &Symbol)`: Revokes a role from an account
* `has_role(e: &Env, account: &Address, role: &Symbol) -> bool`: Checks if an account has a role
* `set_role_admin(e: &Env, role: &Symbol, admin_role: &Symbol)`: Sets the admin role for a role

=== Procedural Macros

The module includes procedural macros to simplify authorization checks:

==== @only_admin

Ensures the caller is the admin before executing the function:

[source,rust]
----
#[only_admin]
pub fn restricted_function(e: &Env, other_param: u32) {
    // Function body - only accessible to admin
}
----

==== @has_role

Ensures the specified parameter has the required role:

[source,rust]
----
#[has_role(account, "minter")]
pub fn mint_tokens(e: &Env, amount: u32, account: Address) {
    // Function body - only accessible to accounts with "minter" role
}
----

== Events

The module emits events for important actions:

* `admin_transfer_initiated`: When an admin transfer is started
* `admin_transfer_completed`: When an admin transfer is completed
* `role_granted`: When a role is granted to an account
* `role_revoked`: When a role is revoked from an account
* `role_admin_changed`: When the admin role for a role is changed

== Usage Example

Here's a simple example of using the Access Control module:

[source,rust]
----
use soroban_sdk::{contract, contractimpl, symbol_short, Address, Env};
use stellar_access_control::{self as access_control, AccessControl};
use stellar_access_control_macros::{has_role, only_admin};

#[contract]
pub struct MyContract;

#[contractimpl]
impl MyContract {
    pub fn __constructor(e: &Env, admin: Address) {
        // Set the contract admin
        access_control::set_admin(e, &admin);

        // Create a "minter" role with admin as its admin
        access_control::set_role_admin_no_auth(e, &symbol_short!("minter"), &symbol_short!("admin"));
    }

    #[only_admin]
    pub fn add_minter(e: &Env, account: Address) {
        // Only the admin can call this function
        access_control::grant_role(e, &account, &symbol_short!("minter"));
    }

    #[has_role(caller, "minter")]
    pub fn mint(e: &Env, caller: Address, to: Address, amount: i128) {
        // Only accounts with "minter" role can call this function
        // Mint implementation...
    }
}
----

== Benefits and Trade-offs

=== Benefits

* Flexible role-based permission system
* Hierarchical role management
* Secure admin transfer process
* Easy integration with procedural macros
* Event emission for important actions

=== Trade-offs

* More complex than single-owner models like Ownable

== See Also

* xref:access/ownable.adoc[Ownable]
* xref:tokens/fungible/fungible.adoc[Fungible Token]
* xref:tokens/non-fungible/non-fungible.adoc[Non-Fungible Token]
